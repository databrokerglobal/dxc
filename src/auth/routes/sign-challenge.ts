import Boom from '@hapi/boom';
import Hapi, { ServerRoute } from '@hapi/hapi';
import Joi from '@hapi/joi';
import { ethers, Wallet } from 'ethers';
import { Challenge } from '../../entity/Challenge';
import { getDb } from '../../lib/db';

export const route: ServerRoute = {
  method: 'POST',
  path: '/auth/sign-challenge',
  options: {
    auth: false,
    tags: ['api'],
    description: 'Signing the challenge with your private key',
    notes:
      'We do not encourage you to use this endpoint. It is bad practice to pass your private key in external systems. Packages for signing Ethereum messages are available for all languages (Java, C#, Go, Rust, Javascript, ...)',
    validate: {
      payload: Joi.object().keys({
        challenge: Joi.string()
          .description('a random string to sign')
          .required()
          .example(
            'silk vacant champion able vast force leave giraffe shock rich neck buyer'
          ),
        privateKey: Joi.string()
          .required()
          .description(
            'the private key for the address that will sign the challenge'
          )
          .example(
            '970C81BEE5F800E04F4455F42A9A0631BD0CB3329A3DF6A5CBEACD96F2263225'
          ),
      }),
    },
    response: {
      status: {
        200: Joi.object().keys({
          signedChallenge: Joi.string()
            .description('the signed challenge')
            .example(
              '0xd5226ee1a0ef02d8c2278008ef1b2b1e427cfc930f0fc52ec27893c2d3a9c4c84700ef7b76c8b7010beb83eb93402bb7ba85d2a0220faf449a45497b282022d91b'
            ),
        }),
      },
    },
  },
  async handler(request: Hapi.Request, h: Hapi.ResponseToolkit) {
    const { challenge, privateKey } = request.payload as any;

    const challengeRepository = getDb(request).getRepository(Challenge);
    const storedChallenge = await challengeRepository.findOne({ challenge });
    if (!storedChallenge) {
      return Boom.notFound(
        'The challenge provided was not generated by this DXC'
      );
    }

    const wallet = new Wallet(privateKey);
    if (wallet.address !== storedChallenge.ethereumAddress) {
      return Boom.notAcceptable(
        'The private key provided does not correspond with the Ethereum address this challenge was created for in this DXC'
      );
    }

    return { signedChallenge: await wallet.signMessage(challenge) };
  },
};
