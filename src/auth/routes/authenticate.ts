import Boom from '@hapi/boom';
import Hapi, { ServerRoute } from '@hapi/hapi';
import Joi from '@hapi/joi';
import { ethers } from 'ethers';
import jsonwebtoken from 'jsonwebtoken';
import { Challenge } from '../../entity/Challenge';
import { getDb } from '../../lib/db';

export const route: ServerRoute = {
  method: 'POST',
  path: '/auth',
  options: {
    auth: false,
    tags: ['api'],
    description: 'Authenticate using a signed challenge from the DXC',
    validate: {
      payload: Joi.object().keys({
        challenge: Joi.string()
          .description('a random string to sign')
          .required()
          .example(
            'silk vacant champion able vast force leave giraffe shock rich neck buyer'
          ),
        signedChallenge: Joi.string()
          .description('the signed challenge')
          .required()
          .example(
            '0xd5226ee1a0ef02d8c2278008ef1b2b1e427cfc930f0fc52ec27893c2d3a9c4c84700ef7b76c8b7010beb83eb93402bb7ba85d2a0220faf449a45497b282022d91b'
          ),
      }),
    },
    response: {
      status: {
        200: Joi.object().keys({
          jwtToken: Joi.string()
            .description('the JWT token needed for all follow up calls')
            .example(
              'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJldGhlcmV1bUFkZHJlc3MiOiIweEE3NGRlNERiQjEyMTMwYzVBNWU5ODIzM0QwNTIwMGQzZEUwZGE3ZDYiLCJpYXQiOjE1NjM0NzQ4MDN9.7ovLEMbkoJEPCp0DZD6fJySnZhrvG9lM3iKSn4fbcSc'
            ),
        }),
      },
    },
  },
  async handler(request: Hapi.Request, h: Hapi.ResponseToolkit) {
    const { challenge, signedChallenge } = request.payload as any;

    // look for the stored challenge and throw an error when we cannot find it
    const challengeRepository = getDb(request).getRepository(Challenge);
    const storedChallenge = await challengeRepository.findOne({ challenge });
    if (!storedChallenge) {
      return Boom.notFound(
        'The challenge provided was not generated by this DXC'
      );
    }

    // checks if the signature matches the encoded message and recovers the signing addresses from it
    const signingAddress = ethers.utils.verifyMessage(
      challenge,
      signedChallenge
    );

    // make sure the address matches the one stored in the database
    if (
      signingAddress.toLowerCase() !==
      storedChallenge.ethereumAddress.toLowerCase()
    ) {
      return Boom.notAcceptable(
        `The signed challenge is not signed by ${storedChallenge.ethereumAddress} but by ${signingAddress}`
      );
    }

    // put the address into the JWT token and sign it.
    const token = jsonwebtoken.sign(
      { ethereumAddress: signingAddress },
      process.env.JWT_SECRET || 's3cr3t'
    );

    // return it and sets it in a cookie as well
    return h
      .response({ jwtToken: token })
      .header('Authorization', token) // where token is the JWT
      .state('token', token, {
        ttl: 365 * 24 * 60 * 60 * 1000, // expires a year from today
        encoding: 'none', // we already used JWT to encode
        isSecure: true, // warm & fuzzy feelings
        isHttpOnly: true, // prevent client alteration
        clearInvalid: false, // remove invalid cookies
        strictHeader: true, // don't allow violations of RFC 6265
      }); // set the cookie with options
  },
};
