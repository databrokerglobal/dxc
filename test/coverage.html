
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/databrokerglobal/dxc/database/any-time.go (0.0%)</option>
				
				<option value="file1">github.com/databrokerglobal/dxc/database/files.go (77.8%)</option>
				
				<option value="file2">github.com/databrokerglobal/dxc/database/manager.go (36.4%)</option>
				
				<option value="file3">github.com/databrokerglobal/dxc/database/products.go (81.2%)</option>
				
				<option value="file4">github.com/databrokerglobal/dxc/database/provide-mock-db.go (80.0%)</option>
				
				<option value="file5">github.com/databrokerglobal/dxc/filemanager/controller.go (48.5%)</option>
				
				<option value="file6">github.com/databrokerglobal/dxc/filemanager/file-checker.go (0.0%)</option>
				
				<option value="file7">github.com/databrokerglobal/dxc/filemanager/file-parser.go (9.1%)</option>
				
				<option value="file8">github.com/databrokerglobal/dxc/products/controller.go (61.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package database

import (
        "database/sql/driver"
        "time"
)

// Struct that mocks date time objects for testing

// AnyTime struct
type AnyTime struct{}

// Match satisfies sqlmock.Argument interface
func (a AnyTime) Match(v driver.Value) bool <span class="cov0" title="0">{
        _, ok := v.(time.Time)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

// CreateFile Query
func (m *Manager) CreateFile(f *File) (err error) <span class="cov8" title="1">{
        m.DB.Create(f)
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetFile Query
func (m *Manager) GetFile(n string) (f *File, err error) <span class="cov8" title="1">{
        file := File{}
        m.DB.Where(&amp;File{Name: n}).First(&amp;file)
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return &amp;file, nil</span>
}

// GetFiles Get all files query
func (m *Manager) GetFiles() (fs *[]File, err error) <span class="cov8" title="1">{
        files := []File{}
        m.DB.Table("files").Find(&amp;files)
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return &amp;files, nil</span>
}

// DeleteFile delete a file
func (m *Manager) DeleteFile(fileName string) (err error) <span class="cov8" title="1">{
        m.DB.Delete(&amp;File{Name: fileName})
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "log"
        "os"

        "github.com/jinzhu/gorm"

        // loading the sqlite dialect
        _ "github.com/jinzhu/gorm/dialects/sqlite"
)

// Manager manage db connection
type Manager struct {
        DB *gorm.DB
}

// NewRepository func
// We can return a Manager struct because all it's methods
// satisfy the Repository interface type
// This allows us to create new Managers using any driver
// TIP: DB() method on a gorm db return a db of type *sql.DB should you need it
func NewRepository(db *gorm.DB) Repository <span class="cov8" title="1">{
        return &amp;Manager{DB: db}
}</span>

// DBInstance database instance
var DBInstance Manager

// Init Singleton
func init() <span class="cov8" title="1">{
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1][:5] == "-test" </span><span class="cov8" title="1">{
                log.Println("Testing: omitting database init")
                return
        }</span>

        <span class="cov0" title="0">db, err := gorm.Open("sqlite3", "./dxc.db")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error connecting to database: ", err)
        }</span>
        <span class="cov0" title="0">DBInstance = Manager{db}
        DBInstance.DB.LogMode(false)
        DBInstance.DB.AutoMigrate(&amp;File{})
        DBInstance.DB.AutoMigrate(&amp;Product{})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

// CreateProduct Query
func (m *Manager) CreateProduct(p *Product) (err error) <span class="cov8" title="1">{
        m.DB.Create(p)
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetProduct Query
func (m *Manager) GetProduct(d string) (p *Product, err error) <span class="cov8" title="1">{
        product := Product{}
        m.DB.Where(&amp;Product{DID: d}).First(&amp;product)
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return &amp;product, nil</span>
}

// GetProducts Get all Products query
func (m *Manager) GetProducts() (ps *[]Product, err error) <span class="cov8" title="1">{
        products := []Product{}
        m.DB.Table("Products").Preload("Files").Find(&amp;products)
        return &amp;products, nil
}</span>

// DeleteProduct delete a Product
func (m *Manager) DeleteProduct(ProductName string) (err error) <span class="cov8" title="1">{
        m.DB.Delete(&amp;Product{Name: ProductName})
        if errs := m.DB.GetErrors(); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                err = errs[0]
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "fmt"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/jinzhu/gorm"
)

var (
        dsnCount int64
)

func provideMockDB() (sqlmock.Sqlmock, *gorm.DB, Repository) <span class="cov8" title="1">{
        dsn := fmt.Sprintf("sqlmock_db_%d", dsnCount)
        _, mock, err := sqlmock.NewWithDSN(dsn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">mockGorm, err := gorm.Open("sqlmock", dsn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">mgr := NewRepository(mockGorm)
        dsnCount++

        return mock, mockGorm, mgr</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package filemanager

import (
        "fmt"
        "io/ioutil"
        "net/http"
        "os"

        "github.com/databrokerglobal/dxc/database"
        "github.com/labstack/echo/v4"
)

// Upload file controller
// Upload godoc
// @Summary Upload a file
// @Description Link a file from the LOCAL_FILES_DIR to the DXC
// @Tags files
// @Accept mpfd
// @Param file formData file true "File to Upload"
// @Produce json
// @Success 200 {string} string true
// @Failure 400 {string} string "File invalid or empty"
// @Failure 404 {string} string "File not found, is the uploaded file in the rigth directory or correctly bound to your docker volume?""
// @Failure 500 {string} string "Error inserting file metadata in database"
// @Router /files/upload [post]
func Upload(c echo.Context) error <span class="cov8" title="1">{

        // Source - File stream from upload
        file, err := c.FormFile("file")

        if err != nil </span><span class="cov8" title="1">{
                return c.String(http.StatusBadRequest, fmt.Sprint("File invalid or empty"))
        }</span>

        // Read file, then open mirror file in dir, read it and check if same file
        <span class="cov0" title="0">err = parseFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusNotFound, "File not found, is the uploaded file in the rigth directory or correctly bound to your docker volume?")
        }</span>

        <span class="cov0" title="0">err = database.DBInstance.CreateFile(&amp;database.File{Name: file.Filename})
        if err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusInternalServerError, "Error inserting file metadata in database")
        }</span>

        // Return succes message
        <span class="cov0" title="0">return c.String(http.StatusOK, fmt.Sprintf("File %s uploaded successfully. File checksum result: OK", file.Filename))</span>
}

// Download a file
// Download godoc
// @Summary Download a file
// @Description Download a file from the DXC
// @Tags files
// @Accept json
// @Param name query string true "File name"
// @Produce octet-stream
// @Success 200 {file} string true
// @Failure 404 {string} string "File not found"
// @Router /files/download [get]
func Download(c echo.Context) error <span class="cov8" title="1">{
        // Read form field
        name := c.QueryParam("name")

        var omit bool

        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1][:5] == "-test" </span><span class="cov8" title="1">{
                omit = true
        }</span>

        <span class="cov8" title="1">if !omit </span><span class="cov0" title="0">{
                _, err := database.DBInstance.GetFile(name)
                if err != nil </span><span class="cov0" title="0">{
                        return c.String(http.StatusNotFound, "File not found")
                }</span>
        }

        <span class="cov8" title="1">var filePath string

        if os.Getenv("GO_ENV") == "local" </span><span class="cov0" title="0">{
                filePath = os.Getenv("LOCAL_FILES_DIR")
        }</span> else<span class="cov8" title="1"> {
                filePath = "/var/files"
        }</span>

        <span class="cov8" title="1">if omit </span><span class="cov8" title="1">{
                filePath = "/tmp"
                testdata := []byte("test")
                if err := ioutil.WriteFile(fmt.Sprintf("%s/%s", filePath, name), testdata, 0644); err != nil </span><span class="cov0" title="0">{
                        return c.String(http.StatusNotFound, "File not found")
                }</span>
        }

        <span class="cov8" title="1">return c.Attachment(fmt.Sprintf("%s/%s", filePath, name), name)</span>
}

// GetAll get all files
// GetFiles godoc
// @Summary Get files
// @Description Get all files linked
// @Tags files
// @Accept json
// @Produce json
// @Success 200 {array} database.File true
// @Failure 500 {string} string "Error retrieving item from database"
// @Router /files [get]
func GetAll(c echo.Context) error <span class="cov0" title="0">{
        var fs *[]database.File

        fs, err := database.DBInstance.GetFiles()

        if err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusInternalServerError, "Error retrieving item from database")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, fs)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package filemanager

import (
        "log"

        "github.com/databrokerglobal/dxc/database"
        "github.com/fatih/color"
)

// CheckingFiles Delete files that are not in directory anymore, restore files that were deleted but now back in their directory
func CheckingFiles() <span class="cov0" title="0">{

        color.Magenta("Checking file integrity...")
        files, err := database.DBInstance.GetFiles()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">for _, file := range *files </span><span class="cov0" title="0">{
                _, err := open(file.Name)
                if err != nil </span><span class="cov0" title="0">{
                        database.DBInstance.DeleteFile(file.Name)
                }</span>
        }

        // Checking if previously deleted files are back up
        <span class="cov0" title="0">var deletedFiles []database.File
        // Unscoped includes soft deleted files in the query
        // Raw allows you to do SQL queries directly
        database.DBInstance.DB.Unscoped().Raw(`SELECT * FROM files WHERE deleted_at IS NOT NULL`).Find(&amp;deletedFiles)

        for _, deletedFile := range deletedFiles </span><span class="cov0" title="0">{
                _, err = open(deletedFile.Name)
                if err == nil </span><span class="cov0" title="0">{
                        // if file opened successfully remove the soft deletion
                        database.DBInstance.DB.Unscoped().Model(&amp;deletedFile).Update("deleted_at", nil)
                }</span>
        }

        <span class="cov0" title="0">yellow := color.New(color.FgYellow).SprintFunc()

        defer color.Green("Finished checking file integrity %s", yellow("\nCurrent file count: ", len(*files)))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package filemanager

import (
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "os"

        "github.com/ethereum/go-ethereum/crypto"
)

// ReadFile read a multipart uploaded file from controller
func parseFile(file *multipart.FileHeader) error <span class="cov0" title="0">{
        // Open file to return its data source
        src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer src.Close()

        uploadedFileSnippet, err := readBytes(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">from, err := open(file.Filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer from.Close()

        localFileSnippet, err := readBytes(from)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if matches := CompareHashes(uploadedFileSnippet, localFileSnippet); !matches </span><span class="cov0" title="0">{
                return errors.New("Files don't match")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Read 22 first bytes and return them
/*
   Because the file can be of type os.File (local dir) or multipart.File (uploaded file),
         we pass the io.Reader interface as an argument which has the Read method used for both types.
*/
func readBytes(file io.Reader) ([]byte, error) <span class="cov0" title="0">{
        b1 := make([]byte, 22)
        n1, err := file.Read(b1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return b1[:n1], nil</span>
}

// CompareHashes checking if hashes are identical
func CompareHashes(file1 []byte, file2 []byte) bool <span class="cov8" title="1">{
        hash1 := crypto.Keccak256(file1)
        hash2 := crypto.Keccak256(file2)

        return string(hash1) == string(hash2)
}</span>

// open file
func open(filename string) (*os.File, error) <span class="cov0" title="0">{
        // Load file path
        var filePath string
        if os.Getenv("GO_ENV") == "local" </span><span class="cov0" title="0">{
                filePath = os.Getenv("LOCAL_FILES_DIR")
        }</span> else<span class="cov0" title="0"> {
                filePath = "/var/files"
        }</span>

        // Open same file in the mounted docker volume (or just local dir if go_env=local)
        <span class="cov0" title="0">from, err := os.Open(fmt.Sprintf("%s/%s", filePath, filename))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return from, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package products

import (
        "bytes"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "strings"

        "github.com/databrokerglobal/dxc/database"
        "github.com/google/uuid"
        "github.com/labstack/echo/v4"
)

func trimLastSlash(host string) (h string) <span class="cov8" title="1">{
        h = host
        for strings.Split(h, "")[len(h)-1] == "/" </span><span class="cov8" title="1">{
                h = strings.TrimSuffix(h, "/")
        }</span>
        <span class="cov8" title="1">return h</span>
}

// ProductController safe type for the controller
type ProductController struct {
        Name  string `json:"name"`
        Type  string `json:"producttype"`
        Host  string `json:"host"`
        Files []database.File
}

// AddOne product
// Create godoc
// @Summary Create Product
// @Description Create a product
// @Tags products
// @Accept json
// @Produce json
// @Param p body ProductController true "Product"
// @Success 201 {object} ProductController "Success"
// @Failure 400 {string} string "Error creating product"
// @Router /product [post]
func AddOne(c echo.Context) error <span class="cov8" title="1">{
        p := new(database.Product)

        if err := c.Bind(p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">status := checkProduct(p)
        if status == http.StatusBadRequest </span><span class="cov0" title="0">{
                return c.String(http.StatusBadRequest, "Name, Type or Host (if product type is not FILE) are empty but are required")
        }</span>

        <span class="cov8" title="1">if p.Type == "FILE" </span><span class="cov0" title="0">{
                p.Host = "N/A"
        }</span>

        <span class="cov8" title="1">if p.Type == "FILE" </span><span class="cov0" title="0">{
                if p.Files == nil </span><span class="cov0" title="0">{
                        return c.String(http.StatusBadRequest, "Product is of type File but no files linked")
                }</span>
                <span class="cov0" title="0">if len(p.Files) == 0 </span><span class="cov0" title="0">{
                        return c.String(http.StatusBadRequest, "Product is of type File but no files linked")
                }</span>
        }

        <span class="cov8" title="1">if p.Type != "FILE" </span><span class="cov8" title="1">{
                newHost := trimLastSlash(p.Host)
                p.Host = newHost
        }</span>

        <span class="cov8" title="1">if p.DID == "" </span><span class="cov0" title="0">{
                p.DID = fmt.Sprintf("did:databroker:%s:%s", p.Name, p.Type)
        }</span>

        <span class="cov8" title="1">var omit bool

        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1][:5] == "-test" </span><span class="cov8" title="1">{
                omit = true
        }</span>

        <span class="cov8" title="1">if !omit </span><span class="cov0" title="0">{
                if err := database.DBInstance.CreateProduct(p); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, p)</span>
}

// GetAll return all products
// GetProducts godoc
// @Summary Get products
// @Description Get all products
// @Tags products
// @Accept json
// @Produce json
// @Success 200 {array} database.Product true
// @Failure 500 {string} string "Error retrieving item from database"
// @Router /products [get]
func GetAll(c echo.Context) error <span class="cov0" title="0">{
        var ps *[]database.Product

        ps, err := database.DBInstance.GetProducts()

        if err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusInternalServerError, "Error retrieving item from database")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, ps)</span>
}

// GetOne product
func GetOne(c echo.Context) error <span class="cov8" title="1">{
        did := c.Param("did")

        var omit bool

        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1][:5] == "-test" </span><span class="cov8" title="1">{
                omit = true
        }</span>

        <span class="cov8" title="1">var err error

        var p *database.Product

        if !omit </span><span class="cov0" title="0">{
                p, err = database.DBInstance.GetProduct(did)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusInternalServerError, "Error retrieving item from database")
        }</span>

        <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                return c.String(http.StatusNotFound, "Product not found")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, p)</span>
}

func checkProduct(p *database.Product) int <span class="cov8" title="1">{
        var status int
        switch </span>{
        case p == nil:<span class="cov8" title="1">
                status = http.StatusBadRequest</span>
        case p.Name == "":<span class="cov8" title="1">
                status = http.StatusBadRequest</span>
        case p.Type == "":<span class="cov8" title="1">
                status = http.StatusBadRequest</span>
        case p.Host == "" &amp;&amp; p.Type != "FILE":<span class="cov8" title="1">
                status = http.StatusBadRequest</span>
        default:<span class="cov8" title="1">
                status = http.StatusContinue</span>
        }
        <span class="cov8" title="1">return status</span>
}

func checkProductForRedirect(p *database.Product) int <span class="cov8" title="1">{
        var status int
        switch </span>{
        case p == nil:<span class="cov8" title="1">
                status = http.StatusNoContent</span>
        case p.Name == "":<span class="cov8" title="1">
                status = http.StatusNoContent</span>
        case p.Type == "":<span class="cov8" title="1">
                status = http.StatusNoContent</span>
        case p.Host == "":<span class="cov8" title="1">
                status = http.StatusNoContent</span>
        case p.Type == "FILE":<span class="cov8" title="1">
                status = http.StatusNoContent</span>
        default:<span class="cov8" title="1">
                status = http.StatusContinue</span>
        }
        <span class="cov8" title="1">return status</span>
}

func parseRequestURL(requestURI string, p *database.Product) string <span class="cov8" title="1">{
        // replace first encounter of product uuid
        newRequestURI := strings.TrimPrefix(strings.Replace(requestURI, p.DID, "", 1), "/")

        requestURLSlice := []string{p.Host, newRequestURI}

        requestURL := strings.Join(requestURLSlice, "")

        return requestURL
}</span>

// RedirectToHost based on product uuid path check if api or stream and subsequently redirect
func RedirectToHost(c echo.Context) error <span class="cov8" title="1">{
        var omit bool

        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1][:5] == "-test" </span><span class="cov8" title="1">{
                omit = true
        }</span>

        <span class="cov8" title="1">slice := strings.Split(c.Request().RequestURI, "/")

        var p *database.Product

        // Check if string in path matches uuid regex, is valid uuid and matches product that is type API or STREAM
        for _, str := range slice </span><span class="cov8" title="1">{

                _, err := uuid.Parse(str)
                if err != nil </span><span class="cov8" title="1">{
                        return c.String(http.StatusNoContent, "")
                }</span>

                <span class="cov0" title="0">if !omit </span><span class="cov0" title="0">{
                        p, err = database.DBInstance.GetProduct(str)
                        if err != nil </span><span class="cov0" title="0">{
                                return c.String(http.StatusNoContent, "")
                        }</span>
                }

                <span class="cov0" title="0">if status := checkProductForRedirect(p); status == http.StatusNoContent </span><span class="cov0" title="0">{
                        return c.String(http.StatusNoContent, "")
                }</span>

                <span class="cov0" title="0">r := buildProxyRequest(c, c.Request(), "http", p.Host)

                err = executeRequest(c, r)</span>
        }

        <span class="cov0" title="0">return c.String(http.StatusNoContent, "")</span>
}

// Take a request and build a proxy request from a host string with a certain protocol (http or https here)
func buildProxyRequest(c echo.Context, r *http.Request, protocol string, host string) *http.Request <span class="cov8" title="1">{
        body, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.String(http.StatusInternalServerError, err.Error())
                return nil
        }</span>

        // if body is of multipart type, reassign it here
        <span class="cov8" title="1">r.Body = ioutil.NopCloser(bytes.NewReader(body))

        // build new url
        url := fmt.Sprintf("%s://%s%s", protocol, host, r.RequestURI)

        proxyReq, err := http.NewRequest(r.Method, url, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                c.String(http.StatusInternalServerError, err.Error())
                return nil
        }</span>

        // Copy header, filter logic could be added later
        <span class="cov8" title="1">proxyReq.Header = make(http.Header)
        for index, value := range r.Header </span><span class="cov0" title="0">{
                proxyReq.Header[index] = value
        }</span>

        <span class="cov8" title="1">return proxyReq</span>
}

func executeRequest(c echo.Context, r *http.Request) error <span class="cov0" title="0">{

        // Instantiate http client
        client := http.Client{}

        resp, err := client.Do(r)
        if err != nil </span><span class="cov0" title="0">{
                return c.String(http.StatusBadGateway, err.Error())
        }</span>

        // Read body
        <span class="cov0" title="0">stream, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        c.String(http.StatusInternalServerError, err.Error())
                        return nil
                }</span>
        }

        // Close reader when response is returned
        <span class="cov0" title="0">defer resp.Body.Close()

        return c.Blob(resp.StatusCode, resp.Header.Get("Content-Type"), stream)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
